# 1) lambda функции

# Ранее функция записывалась так

def sum(x):
    return x+10

def mult(x):
    return x**2

print(sum(mult(2)))

# А так можно сделать через лябмда функцию

sum = lambda x: x+10
mult = lambda x: x**2

print(sum(mult(2))) # также можно записать как h(lambda x: x+10, lambda x: x**2, 5)

3) Функция index() в Python

Метод index() возвращает индекс указанного элемента в списке. 
Синтаксис метода в Python: list.index(element, start, end)

4.1) Метод split() разбивает строку по указанному разделителю и возвращает список строк. 
Синтаксис: str.split([separator [, maxsplit]]) Параметры Метод в Python принимает максимум 2 параметра: 
разделитель (необязательно) ‒ это разделитель. Строка разделяется по указанному разделителю. 
Если разделитель не указан, любая строка с пробелами (пробел, новая строка и т.д.) является разделителем. 

maxsplit (необязательно) ‒ maxsplit определяет максимальное количество разделений. 
Значение maxsplit по умолчанию ‒ -1, что означает отсутствие ограничения на количество разделений.

text= 'Love thy neighbor' # splits at space 
print(text.split()) 
grocery = 'Milk, Chicken, Bread' # splits at ',' 
print(grocery.split(', ')) # Splitting at ':' 
print(grocery.split(':')) 

Вывод ['Love', 'thy', 'neighbor'] ['Milk', 'Chicken', 'Bread'] ['Milk, Chicken, Bread']

4.2) Метод join() для формирования строки из подстрок.

<sep>.join(<iterable>)

Здесь <iterable> – любой итерируемый объект Python, содержащий подстроки. 
Это может быть, например, список или кортеж. 
<sep> – это разделитель, с помощью которого вы хотите объединить подстроки.


# ['Apples', 'Oranges', 'Pears', 'Bananas', 'Berries']
", ".join(my_list)
# Output: Apples, Oranges, Pears, Bananas, Berries

5) Функция map() применяет указанную функцию к
каждому элементу итерируемого объекта и
возвращает итератор с новыми объектами.

f(x) ⇒ x + 10
map(f, [ 1, 2, 3, 4, 5])

[ 11, 12, 13, 14, 15] # прибавила к каждому элементу по 10

6) Функция filter() применяет указанную функцию к
каждому элементу итерируемого объекта и
возвращает итератор с теми объектами, для
которых функция вернула True.
f(x) ⇒ x - чётное
filter(f, [ 1, 2, 3, 4,5])

[ 2, 4 ] # Нечётные элементы были отфильтрованы

7)  Функция zip() применяется к набору итерируемых
объектов и возвращает итератор с кортежами из
элементов входных данных.
Количество элементов в результате равно минимальному количеству элементов входного набора
zip ([1, 2, 3], [ ‘о‘, ‘д‘, ‘т‘], [‘f’,’s’,’t’])
↓
[(1, 'о', 'f'), (2, 'д', 's'), (3, 'т', 't')]


8) Функция enumerate() применяется к итерируемому
объекту и возвращает новый итератор с кортежами
из индекса и элементов входных данных.
enumerate(['Казань', 'Смоленск', 'Рыбки', 'Чикаго'])

[(0, 'Казань'), (1, 'Смоленск'), (2, 'Рыбки'), (3, 'Чикаго')]

Синтаксис
enumerate(iterable, start=0)

# start (необязательно) — enumerate() начинает отсчет с этого числа. Если start опущен, 0 принимается за начало.

9) List Comprehension
[exp for item in iterable]
[exp for item in iterable (if conditional)]
[exp <if conditional> for item in iterable (if conditional)]


# List comprehension  - генератор списков, более удобный вариант цикла for

# ранее записывали так:
squares = []
for x in range(10):
  squares.append(x ** 2)
# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# через List comprehension будет так:

squares = [x ** 2 for x in range(10)]
# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# более сложные примеры:
добавление условия if
>>> odds = [x for x in range(10) if x % 2 != 0]
# [1, 3, 5, 7, 9]


добваление условия else
>>> [x ** 2 if x % 2 == 0 else x ** 3 for x in range(10)]
# [0, 1, 4, 27, 16, 125, 36, 343, 64, 729]


# работа с двумя списками
first = [] # Старый вариант записи

for x in range(1, 5):
  for y in range(5, 1, -1):
    if x != y:
      first.append((x, y))

second = [(x, y) for x in range(1, 5) for y in range(5, 1, -1) if x != y] # новый вариант записи

10) Функция reduce() модуля functools кумулятивно применяет функцию function к элементам итерируемой iterable последовательности, сводя её к единственному значению. 

# Синтаксис:
from functools import reduce
reduce(function, iterable[, initializer])

# Параметры:
    function - пользовательская функция, принимающая 2 аргумента,
    iterable - итерируемая последовательность,
    initializer - начальное значение.

# Возвращаемое значение:
    требуемое единственное значение.


Например reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) вычисляет ((((1 + 2) +3) +4) +5). 
Левый аргумент x - это накопленное значение, а правый аргумент y - это следующий элемент iterable.

Если присутствует необязательный initializer, он помещается перед элементами iterable в вычислении. 
Другими словами это базовое значение, с которого требуется начать отсчёт. 
Аргумент initializer, так же служит значением по умолчанию, когда iterable является пустым.

Вычисление суммы всех элементов списка при помощи reduce:

from functools import reduce
items = [10, 20, 30, 40, 50]
sum_all = reduce(lambda x,y: x + y, items)
sum_all
# 150

Вычисление наибольшего элемента в списке при помощи reduce:

from functools import reduce
items = [1, 24, 17, 14, 9, 32, 2]
all_max = reduce(lambda a,b: a if (a > b) else b, items)
all_max
# 32



11) # Пример кода:

data = '1 2 3 5 8 15 23 38'.split()
data = list(map(int, data))
data = list(filter(lambda e: not e % 2, data))
data = list(map(lambda e: (e, e**2), data))
print(data)